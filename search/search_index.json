{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Project overview","text":"<ul> <li>Tutorials: <ul> <li>Undertanding run_conditionally</li> <li>Qonscious notebooks </li> </ul> </li> <li>How-to guides: <ul> <li>Contribute to this project</li> <li>Create a new Backend Adapter (coming soon)</li> <li>Create a new Figure of Merit (coming son)</li> </ul> </li> <li>Reference (API): see API Reference</li> <li>Explanations/Design: (coming soon)</li> </ul>"},{"location":"#qonscious","title":"Qonscious","text":"<p>Qonscious is a runtime framework designed to support conditional execution of quantum circuits based on resource introspection. It helps you build quantum applications that are aware of backend conditions \u2014 such as entanglement, coherence, or fidelity \u2014 before execution.</p>"},{"location":"#why-qonscious","title":"Why Qonscious?","text":"<p>In the NISQ era, quantum hardware is noisy, resource-limited, and variable over time. Static resource assumptions lead to unreliable results. Qonscious makes quantum programs introspective and adaptive.</p> <p>For a deeper discusion on the motivation behind Qonscious, read our article</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Figures of Merit evaluation (e.g., get CHSH score)</li> <li>Conditional execution on compliance with figures of merit checks</li> <li>Inversion of control: pass a callback, not a circuit</li> <li>Built-in logging, extensibility, and fallback logic</li> </ul>"},{"location":"#use-cases","title":"Use cases","text":"<p>These are some scenarios where you may use Qonscious:</p> <ul> <li>Run a circuit conditional on your target computer (or simulator) checking some figures of merit (e.g., number of qubits, CHSH score, etc.)</li> <li>Benchmark a computer (or simulator) in terms of a collection of figures of merit.</li> <li>Explore correlations between experiment results and figures of merit of a gicen computer (or simulator)</li> <li>...</li> </ul>"},{"location":"#setting-up-dependencies","title":"Setting up dependencies","text":"<p>This project is organized with a pyproject.toml file, so there is no longer a need for a requirements.txt file.</p> <p>Python version is set in .python-version</p> <p>We recommend working in a Python virtual environment. The following snippet of code provides examples of most of the tasks you'll need to complete. </p> <pre><code>python -m venv .venv \nsource .venv/bin/activate\npip install -U pip wheel\npip install -e \".[dev,notebooks,viz,docs]\" # you can leave notebooks and viz out of you are only working on the framework.\n</code></pre> <p>The -e flag in pip install tells pip to install Qonscious as a dependency so you can import from any Jupyter notebook working on the same venv while lettig you edit the framework.</p>"},{"location":"#documentation","title":"Documentation","text":"<p>Up to date documentation is available on github pages</p>"},{"location":"#examples","title":"Examples","text":"<p>The notebooks folder contains several examples of using Qonscious in different use cases. </p> <p>We suggest you start with chsh_test_demo.ipynb</p>"},{"location":"#development-notes","title":"Development notes","text":""},{"location":"#visualstudio-code","title":"VisualStudio Code","text":"<p>There is a _vscode_example_settings.json file that you can rename to .vscode/settings.json . It provides most default settings that help VSC find tests, work with notebooks, etc. </p>"},{"location":"#ruff","title":"ruff","text":"<p>pyproject.toml includes default configurations for ruff (linting, etc.). Ruff is part of the [dev] dependencies.</p> <p>To use ruff from the command line (and let ruff format, and tidy up code),  do as follows:</p> <pre><code>ruff check . --fix\nruff format .\n</code></pre>"},{"location":"#pyright","title":"pyright","text":"<p>This project uses pyright as a typechecker (In VSCode it will work via PyLance).</p> <p>Settings are defined in pyrightconfig.json</p>"},{"location":"changelog/","title":"Changelog","text":"<p>Example content to imitate</p>"},{"location":"changelog/#changelog","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file. The format is based on Keep a Changelog and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#001-2025-09-02","title":"[0.0.1] - 2025-09-02","text":"<p>First version that shows all of Qonscions in a clear and almost mature way. APIs and desing will still be changed. </p>"},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Documentation that is deployed automatically to github pages</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Package organization was improved with learnability in mind</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Few bugs.</li> </ul>"},{"location":"changelog/#comming","title":"Comming","text":"<ul> <li>Document result types</li> <li>Actions can be chained (thus, we would get a collection of QuonsciousResults)</li> </ul>"},{"location":"how-to/contributing/","title":"1. Introduction / Welcome","text":"<p>Thanks for your interest in Qonscious. You are welcomed to contribute with improvements, fixes, and extensions. Just keep in mind that Qonscious is in active development and it is part of a research project. In that context, we may not be able (or willing to) integrate all proposals. However, you can work on you own version of Qonsiocus is you cite this work.  </p>"},{"location":"how-to/contributing/#2-code-of-conduct-link-or-summary","title":"2.    Code of Conduct (link or summary)","text":"<ul> <li>Be nice.</li> <li>Be prepare for APIs to change. </li> <li>If you use Qonscious (or find it interesting), reference it.</li> <li>If you write an article talking about or using Qonscious, cite one of the articles listed in the project's home page. </li> </ul>"},{"location":"how-to/contributing/#3-how-to-contribute","title":"3.    How to Contribute","text":"<ul> <li>Report bugs and suggest features as Github issues.</li> <li>Asking questions by email to any of the maintainers.</li> <li>Use (piecemeal) pull request to propose changes.</li> <li>Document your code as described below.</li> </ul>"},{"location":"how-to/contributing/#4-what-to-contribute","title":"4.    What to contribute","text":"<p>Qonscious is an experimentation platform. As such, it already foresees a few extension points (where you can hang your contributions). Each of these extension point is present in the design as an abstract class, dictype or protocol that you can extend. </p> <ul> <li> <p>Adapters: Adapters (backend adapters) give Qonscious users independence from specific vendor APIs. Using adapters makes a tradeoff between abstraction (polimorphic APIs) and control (using QPU specific features). </p> </li> <li> <p>Functions of merit: Functions of Merit (FoM's) capture the charateristics of a quantum computing platform (QPU or Simulator) that are relevant for computing. Creating and using FoM's is Qonscious way on reflecting and learning about quantum computation resources in the NISQ era.</p> </li> </ul> <p>Notebooks: You can also contribute with usage examples in the form of Jupyter notebooks that use Qonscious. </p> <p>Merit compliance checks You often use FoM's to check if a given backend (i.e., adapted backend) offers the resources your use case needs. Checks (implementes as instances of the MeritComplianceCheck class) combine a FoM with a callback function that takes the result of checking that FoM on the backend and resutls true of false. Writing these checks is a bit convoluted so having many examples is useful.</p>"},{"location":"how-to/contributing/#5-versioning-and-releasing","title":"5.    Versioning and releasing","text":"<p>In the current phase of development, the design of Qonscious will change often. As we create new FoMs, provide new backend adapters, and explore usage scenarios, the API will change. There will be no PyPI version you can install with pip. For the time being, you install with <code>pip install -e</code></p>"},{"location":"how-to/contributing/#6-development-notes","title":"6.    Development notes","text":""},{"location":"how-to/contributing/#typing","title":"Typing","text":"<p>This project uses pyright as a typechecker (In VSCode it will work via PyLance). Settings are defined in pyrightconfig.json</p>"},{"location":"how-to/contributing/#formating-and-linting","title":"Formating and linting","text":"<p>This project uses ruff for formating, linting, etc.</p> <p>pyproject.toml includes default configurations for ruff</p> <p>Ruff is part of the [dev] dependencies.</p> <p>To use ruff from the command line (and let ruff format, and tidy up code),  do as follows:</p> <pre><code>ruff check . --fix\nruff format .\n</code></pre>"},{"location":"how-to/contributing/#testing","title":"Testing","text":"<p>Make sure that any extensions/improvement/changes you contribute are covered by unit tests.</p> <p>Mark test methods that interact with IBM's backend (thus requiring a token) with the annotation <code>@pytest.mark.ibm_token_required</code></p> <p>Use: * <code>pytest</code> : to run all tests * <code>pytest -m \"not ibm_token_required\"</code> : to only run tests that to not interact with IBM's backend * <code>pytest -m \"ibm_token_required\"</code> : to only run tests that that do interact with IBM's backend</p>"},{"location":"how-to/contributing/#visualstudio-code","title":"VisualStudio Code","text":"<p>There is a _vscode_example_settings.json file that you can rename to .vscode/settings.json . It provides most default settings that help VSC find tests, work with notebooks, etc. </p>"},{"location":"how-to/contributing/#keep-documentation-up-to-date","title":"Keep documentation up to date","text":"<p>We use mkdocs + mkdocstrings to generate documentation.</p>"},{"location":"how-to/contributing/#one-time-setup","title":"One-time setup","text":"<ul> <li>Install deps: <code>pip install -e \".[docs]\"</code> (or <code>pip install mkdocs mkdocs-material mkdocstrings[python]</code>)</li> <li>Ensure you have:</li> <li><code>mkdocs.yml</code> at repo root</li> <li><code>docs/index.md</code>, <code>docs/reference/index.md</code> (with <code>::: qonscious</code>)</li> </ul>"},{"location":"how-to/contributing/#write-good-docstrings-type-hints","title":"Write good docstrings + type hints","text":"<ul> <li>Use Google style consistently.</li> <li>Public APIs should document: summary, Args, Returns, Raises, Examples.</li> </ul>"},{"location":"how-to/contributing/#preview-locally-while-writing","title":"Preview locally while writing","text":"<pre><code>mkdocs serve\n</code></pre>"},{"location":"reference/","title":"API Reference","text":"<p>Qonscious combines backend adapters, figures of merits, merit compliance checks, and actions to abstract what it means to perform resource aware conditional quantum computation in the NISQ era.</p>"},{"location":"reference/#adapters","title":"Adapters","text":"<p>A BackendAdapter is the abstraction layer in Qonscious that standardizes access to quantum backends, whether they are real devices, cloud simulators, or local emulators. It exposes a uniform interface for executing quantum circuits and retrieving results in a consistent format, including counts, backend characteristics, and execution metadata. This allows Qonscious to remain agnostic to the specifics of backend APIs (such as IBM Sampler or Aer), while still supporting resource introspection, circuit execution, measurement, and runtime resource checks. Developers are free to implement custom adapters to integrate other platforms.</p> <p>You can create an adapter on Qiskit's SamplerV2 as follows:</p> <pre><code>from qonscious.adapters import AerSamplerAdapter\nbackend = AerSamplerAdapter()\n</code></pre> <p>You can create an adapter to work with one of IBM's fake (simulated computers) as follows:</p> <pre><code>from qiskit_ibm_runtime.fake_provider import FakeManilaV2\nfrom qonscious.adapters import IBMSamplerAdapter\nadapter = IBMSamplerAdapter(FakeManilaV2()) # edit as needed\n</code></pre> <p>You can create an adapter on IBM's least bussy (real) quantum computer as follows:</p> <pre><code>from qonscious.adapters import IBMSamplerAdapter\nibm_token = os.getenv(\"IBM_QUANTUM_TOKEN\") # edit as needed\nadapter = IBMSamplerAdapter.least_busy_backend(ibm_token)\n</code></pre>"},{"location":"reference/#qonscious.adapters.backend_adapter.BackendAdapter","title":"<code>BackendAdapter</code>","text":"<p>               Bases: <code>Protocol</code></p> Source code in <code>src/qonscious/adapters/backend_adapter.py</code> <pre><code>class BackendAdapter(Protocol):\n    def run(self, circuit: QuantumCircuit, **kwargs) -&gt; ExperimentResult: ...\n\n    @property\n    def n_qubits(self) -&gt; int:\n        \"\"\"\n        Returns:\n            int: The number of qubits of the backend.\n        \"\"\"\n        ...\n\n    @property\n    def t1s(self) -&gt; dict[int, float]:\n        \"\"\"\n        Returns:\n            dict[int, float]: The T1 (relaxation time) for each qubit.\n        \"\"\"\n        ...\n\n    @property\n    def t2s(self) -&gt; dict[int, float]:\n        \"\"\"\n        Returns:\n            dict[int, float]: The T2 (dephasing time) for each qubit.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"reference/#qonscious.adapters.backend_adapter.BackendAdapter.n_qubits","title":"<code>n_qubits</code>  <code>property</code>","text":"<p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of qubits of the backend.</p>"},{"location":"reference/#qonscious.adapters.backend_adapter.BackendAdapter.t1s","title":"<code>t1s</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>dict[int, float]</code> <p>dict[int, float]: The T1 (relaxation time) for each qubit.</p>"},{"location":"reference/#qonscious.adapters.backend_adapter.BackendAdapter.t2s","title":"<code>t2s</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>dict[int, float]</code> <p>dict[int, float]: The T2 (dephasing time) for each qubit.</p>"},{"location":"reference/#figures-of-merit","title":"Figures of merit","text":"<p>A Figure of Merit in Qonscious represents a measurable property of a quantum backend (device or simulator) that is relevant to the quality or feasibility of circuit execution. Examples include physical metrics such as average T\u2081 time, CHSH score, or backend connectivity, as well as derived quantities like estimated circuit error after transpilation. When a figure of merit is evaluated, it produces a structured object called a Figure of Merit Result, which contains the computed value (or outcome), relevant metadata (such as backend name, timestamps, or raw introspection data), and any additional fields needed to interpret the result. These results are in merit checks to determine whether the backend conditions meet the criteria required for executing a quantum task.</p> <p>You can use Figures of Merit as stand-alone objects, to analyse a backend but you normally used them in merit checks of the run_conditional() function.</p> <p>You can get an aggregate figure of merit (T1, T2, numer of qubits, etc) of IBM's least bussy computer as follows:</p> <pre><code>import os\nfrom qonscious.adapters import IBMSamplerAdapter\nfrom qonscious.foms.aggregate_qpu_fom import AggregateQPUFigureOfMerit\n\nibm_token = os.getenv(\"IBM_QUANTUM_TOKEN\")\nadapter = IBMSamplerAdapter.least_busy_backend(ibm_token)\nagg_fom = AggregateQPUFigureOfMerit()\nagg_fom.evaluate(adapter)\n</code></pre> <p>You can see what the CHSH (a figure of merit) looks like in IBM's FakeKawasaki() as follows. Pay attention to the properties attribute of the result object.</p> <pre><code>from qiskit_ibm_runtime.fake_provider import FakeKawasaki\nfrom qonscious.adapters import IBMSamplerAdapter\nfrom qonscious.foms import PackedCHSHTest\n\nadapter = IBMSamplerAdapter(FakeKawasaki())\nchsh_test = PackedCHSHTest()\nchsh_test.evaluate(adapter)\n</code></pre>"},{"location":"reference/#qonscious.foms.aggregate_qpu_fom.AggregateQPUFigureOfMerit","title":"<code>AggregateQPUFigureOfMerit</code>","text":"<p>               Bases: <code>FigureOfMerit</code></p> <p>I aggregate various properties common to all backends in a single FOM. I aggregate: n_qubits, T1 average, T2 average, ... For multivalued figures such as T1, I provide a dict with  descriptive statistics</p> Source code in <code>src/qonscious/foms/aggregate_qpu_fom.py</code> <pre><code>class AggregateQPUFigureOfMerit(FigureOfMerit):\n    \"\"\"\n    I aggregate various properties common to all backends in a single FOM.\n    I aggregate: n_qubits, T1 average, T2 average, ...\n    For multivalued figures such as T1, I provide a dict with  descriptive statistics\n    \"\"\"\n\n    def evaluate(self, backend_adapter: BackendAdapter, **kwargs) -&gt; FigureOfMeritResult:\n        result: FigureOfMeritResult = {\n            \"timestamp\": datetime.now(timezone.utc).isoformat(),\n            \"figure_of_merit\": self.__class__.__name__,\n            \"properties\": {\n                \"n_qubits\": backend_adapter.n_qubits,\n                \"T1\": describe(list(backend_adapter.t1s.values()), \"cap\", cap_value=1),\n                \"T2\": describe(list(backend_adapter.t2s.values()), \"cap\", cap_value=1),\n            },\n            \"experiment_result\": None,\n        }\n        return result\n</code></pre>"},{"location":"reference/#qonscious.foms.packed_chsh.PackedCHSHTest","title":"<code>PackedCHSHTest</code>","text":"<p>               Bases: <code>FigureOfMerit</code></p> <p>I represent a CHSH test, run on 8 qubits (the four Bell pairs), in parallel.</p> Source code in <code>src/qonscious/foms/packed_chsh.py</code> <pre><code>class PackedCHSHTest(FigureOfMerit):\n    \"\"\"\n    I represent a CHSH test, run on 8 qubits (the four Bell pairs), in parallel.\n    \"\"\"\n\n    def evaluate(self, backend_adapter: BackendAdapter, **kwargs) -&gt; FigureOfMeritResult:\n        \"\"\"\n        Returns:\n            a FigureOfMeritResult with the following properties:\n                figure_of_merit: \"PackedCHSHTest\" (a str).\n                properties: a dict with keys \"E00\", \"E01\", \"E10\", \"E11\", representing the individual\n                counts of each observed pait, and \"score\", computed as E00 + E01 + E10 - E11.\n                experiment_result: an instance of ExperimentResult; the result of the experiment.\n        \"\"\"\n        qc = self._build_circuit()\n        run_result: ExperimentResult = backend_adapter.run(qc, shots=kwargs.get(\"shots\", 1024))\n        CHSH_Scores: dict = compute_parallel_CHSH_scores(run_result[\"counts\"])\n        evaluation_result: FigureOfMeritResult = {\n            \"timestamp\": datetime.now(timezone.utc).isoformat(),\n            \"figure_of_merit\": self.__class__.__name__,\n            \"properties\": CHSH_Scores,\n            \"experiment_result\": run_result,\n        }\n        return evaluation_result\n\n    def _build_circuit(self) -&gt; QuantumCircuit:\n        qc = QuantumCircuit(8, 8)\n\n        for i in range(0, 8, 2):\n            qc.h(i)\n            qc.cx(i, i + 1)\n\n        # Measurement settings\n        qc.ry(-np.pi / 4, 1)\n        qc.ry(np.pi / 4, 3)\n        qc.ry(-np.pi / 2, 4)\n        qc.ry(-np.pi / 4, 5)\n        qc.ry(-np.pi / 2, 6)\n        qc.ry(np.pi / 4, 7)\n\n        qc.measure(range(8), range(8))\n        return qc\n</code></pre>"},{"location":"reference/#qonscious.foms.packed_chsh.PackedCHSHTest.evaluate","title":"<code>evaluate(backend_adapter, **kwargs)</code>","text":"<p>Returns:</p> Type Description <code>FigureOfMeritResult</code> <p>a FigureOfMeritResult with the following properties: figure_of_merit: \"PackedCHSHTest\" (a str). properties: a dict with keys \"E00\", \"E01\", \"E10\", \"E11\", representing the individual counts of each observed pait, and \"score\", computed as E00 + E01 + E10 - E11. experiment_result: an instance of ExperimentResult; the result of the experiment.</p> Source code in <code>src/qonscious/foms/packed_chsh.py</code> <pre><code>def evaluate(self, backend_adapter: BackendAdapter, **kwargs) -&gt; FigureOfMeritResult:\n    \"\"\"\n    Returns:\n        a FigureOfMeritResult with the following properties:\n            figure_of_merit: \"PackedCHSHTest\" (a str).\n            properties: a dict with keys \"E00\", \"E01\", \"E10\", \"E11\", representing the individual\n            counts of each observed pait, and \"score\", computed as E00 + E01 + E10 - E11.\n            experiment_result: an instance of ExperimentResult; the result of the experiment.\n    \"\"\"\n    qc = self._build_circuit()\n    run_result: ExperimentResult = backend_adapter.run(qc, shots=kwargs.get(\"shots\", 1024))\n    CHSH_Scores: dict = compute_parallel_CHSH_scores(run_result[\"counts\"])\n    evaluation_result: FigureOfMeritResult = {\n        \"timestamp\": datetime.now(timezone.utc).isoformat(),\n        \"figure_of_merit\": self.__class__.__name__,\n        \"properties\": CHSH_Scores,\n        \"experiment_result\": run_result,\n    }\n    return evaluation_result\n</code></pre>"},{"location":"reference/#merit-checks","title":"Merit checks","text":"<p>You use figures of merit to evaluate whether a quantum computer meets the requirements of your experiment. A merit check consists of computing a figure of merit on a given backend and then deciding, based on the result, whether the device passes or fails your criteria.</p> <p>The current mechanism for performing such a check is the MeritComplianceCheck, which takes two components:</p> <ul> <li>a FigureOfMerit that defines what to measure, and</li> <li>a decision function that receives the result of the measurement and returns True (pass) or False (fail).</li> </ul> <p>For example, the following code checks whether IBM\u2019s FakeKawasaki simulator is capable of producing a level of entanglement high enough to yield a CHSH score greater than 2.7 (run it a few times; 2.7 is in the limit of that fake computer)</p> <pre><code>from qiskit_ibm_runtime.fake_provider import FakeKawasaki\n\nfrom qonscious.adapters import IBMSamplerAdapter\nfrom qonscious.checks import MeritComplianceCheck\nfrom qonscious.foms import PackedCHSHTest\n\nadapter = IBMSamplerAdapter(FakeKawasaki())\n\n# Build the compliance check using a PackedCHSHTest and the score-checking function (a lambda in this case)\nchsh_compliance = MeritComplianceCheck(\n    figure_of_merit=PackedCHSHTest(),\n    decision_function=lambda chsh_result: chsh_result is not None and\n        chsh_result[\"properties\"][\"score\"] &gt; 2.7,\n)\n\nchsh_compliance.check(adapter)\n</code></pre> <p>This approach lets you define flexible and reusable checks based on any figure of merit supported by Qonscious; not just CHSH, but also qubit count, coherence time, circuit error estimates, or even custom benchmarks.</p>"},{"location":"reference/#qonscious.checks.merit_compliance_check.MeritComplianceCheck","title":"<code>MeritComplianceCheck</code>","text":"<p>A flexible compliance check based on an optional Figure of Merit and a custom decision function that maps its result to a boolean.</p> Source code in <code>src/qonscious/checks/merit_compliance_check.py</code> <pre><code>class MeritComplianceCheck:\n    \"\"\"\n    A flexible compliance check based on an optional Figure of Merit\n    and a custom decision function that maps its result to a boolean.\n    \"\"\"\n\n    def __init__(\n        self,\n        figure_of_merit: FigureOfMerit | None = None,\n        decision_function: Callable[[FigureOfMeritResult | None], bool] = lambda _: True,\n    ):\n        self.figure_of_merit = figure_of_merit\n        self.decision_function = decision_function\n\n    def check(self, backend_adapter: BackendAdapter, **kwargs) -&gt; dict:\n        \"\"\"\n        Evaluate the FOM if present, apply the decision function to its result,\n        and return a dict with the compliance outcome and the FOM result (if any).\n        \"\"\"\n        fom_result = None\n\n        if self.figure_of_merit is not None:\n            fom_result = self.figure_of_merit.evaluate(backend_adapter, **kwargs)\n\n        passed = self.decision_function(fom_result)\n\n        return {\"passed\": passed, \"fom_result\": fom_result}\n</code></pre>"},{"location":"reference/#qonscious.checks.merit_compliance_check.MeritComplianceCheck.check","title":"<code>check(backend_adapter, **kwargs)</code>","text":"<p>Evaluate the FOM if present, apply the decision function to its result, and return a dict with the compliance outcome and the FOM result (if any).</p> Source code in <code>src/qonscious/checks/merit_compliance_check.py</code> <pre><code>def check(self, backend_adapter: BackendAdapter, **kwargs) -&gt; dict:\n    \"\"\"\n    Evaluate the FOM if present, apply the decision function to its result,\n    and return a dict with the compliance outcome and the FOM result (if any).\n    \"\"\"\n    fom_result = None\n\n    if self.figure_of_merit is not None:\n        fom_result = self.figure_of_merit.evaluate(backend_adapter, **kwargs)\n\n    passed = self.decision_function(fom_result)\n\n    return {\"passed\": passed, \"fom_result\": fom_result}\n</code></pre>"},{"location":"reference/#conditionally-running-circuits","title":"Conditionally running circuits","text":"<p>You use Qoncsious to conditionaly (being aware of the resources on your computing platform) perform actions. This could be running a quantum circuit, reporting results, or running any arbitrary function. We call these actions, qonscious actions. A QonsciousAction is objects that implement the <code>run()</code> method, which receives a backend adapter, the results of figure-of-merit evaluations, and optional keyword arguments. The method returns either an ExperimentResult or None.</p> <p>This example shows how to use a QonsciousCircuit object, to run a simple quantum circuit. It basically does nothing with the figures of merit it receives (they are important in other scenarios), therefore we send an empty list.</p> <p>The result is a QonsciousResult object, that provides a uniform way to access the bistrings counts, execution stats, the raw results returned by the real backend. </p> <pre><code>from qiskit import QuantumCircuit\n\nfrom qonscious.actions import QonsciousCircuit\nfrom qonscious.adapters import IBMSamplerAdapter\n\n# A simple Bell state\nphi_plus = QuantumCircuit(2)\nphi_plus.h(0)\nphi_plus.cx(0, 1)\nphi_plus.measure_all()\n\nq_action = QonsciousCircuit(phi_plus)\nadapter = IBMSamplerAdapter(FakeKawasaki())\nq_result = q_action.run(adapter,[],shots=2048)\n</code></pre> <p>This example shows how to use a QonsciousCallable to wrap a python function that logs the score of the CHSH test (a merit test).</p> <pre><code>from qiskit_ibm_runtime.fake_provider import FakeKawasaki\n\nfrom qonscious.actions import QonsciousCallable\nfrom qonscious.adapters import IBMSamplerAdapter\nfrom qonscious.checks import MeritComplianceCheck\nfrom qonscious.foms import PackedCHSHTest\n\nadapter = IBMSamplerAdapter(FakeKawasaki())\n\nchsh_compliance = MeritComplianceCheck(\n    figure_of_merit=PackedCHSHTest(),\n    decision_function=lambda chsh_result: chsh_result is not None and\n        chsh_result[\"properties\"][\"score\"] &gt; 2.7,\n)\n\nchsg_result = chsh_compliance.check(adapter)[\"fom_result\"]\n\ndef log_chsh_score(backend_adapter, figureOfMeritResults):\n    firstFoMResult = figureOfMeritResults[0]\n    print(f\"CHSH Score: {firstFoMResult['properties']['score']:.3f}\")\n    return None\n\nq_callable = QonsciousCallable(log_chsh_score)\nq_callable.run(adapter,[chsg_result])\n</code></pre> <p>That last example looks a bit cumbersome. Luckily, we use actions via the run_conditionally function. </p> <p>So, if we put all of that together, we get:</p> <pre><code>from qiskit_ibm_runtime.fake_provider import FakeKawasaki\n\nfrom qonscious import run_conditionally\nfrom qonscious.actions import QonsciousCallable\nfrom qonscious.adapters import IBMSamplerAdapter\nfrom qonscious.checks import MeritComplianceCheck\nfrom qonscious.foms import PackedCHSHTest\n\n# Prepare our backend adapter\nadapter = IBMSamplerAdapter(FakeKawasaki())\n\n# Prepare our check - CHSH score over 2.7\nchsh_compliance = MeritComplianceCheck(\n    figure_of_merit=PackedCHSHTest(),\n    decision_function=lambda chsh_result: chsh_result is not None and\n        chsh_result[\"properties\"][\"score\"] &gt; 2.7,\n)\n\n# Prepare our action for the case CHSH is over 2.7 (A Bell pair)\nphi_plus = QuantumCircuit(2)\nphi_plus.h(0)\nphi_plus.cx(0, 1)\nphi_plus.measure_all()\npass_action = QonsciousCircuit(phi_plus)\n\n# Prepare our action for the case CHSH in under 2.7 (report the score)\ndef log_chsh_score(backend_adapter, figureOfMeritResults):\n    firstFoMResult = figureOfMeritResults[0]\n    print(f\"CHSH score was too low: {firstFoMResult['properties']['score']:.3f}\")\n    return None\nfail_action = QonsciousCallable(log_chsh_score)\n\n# Run either one of the actions conditionally on the CHSH figure of merit of our backend\nq_result = run_conditionally(adapter, [chsh_compliance], pass_action, fail_action)\n\nprint(q_result)\n</code></pre>"},{"location":"reference/#qonscious.actions.qonscious_circuit.QonsciousCircuit","title":"<code>QonsciousCircuit</code>","text":"<p>               Bases: <code>QonsciousAction</code></p> <p>A Quantum circuit wrapped as as QonsciousAction</p> <p>Attributes:</p> Name Type Description <code>circuit</code> <code>QuantumCircuit</code> <p>the quantum circuit to run</p> Source code in <code>src/qonscious/actions/qonscious_circuit.py</code> <pre><code>class QonsciousCircuit(QonsciousAction):\n    \"\"\"\n    A Quantum circuit wrapped as as QonsciousAction\n\n    Attributes:\n        circuit (QuantumCircuit): the quantum circuit to run\n    \"\"\"\n\n    def __init__(self, circuit: QuantumCircuit):\n        self.circuit = circuit\n\n    def run(\n        self, backend_adapter: BackendAdapter, fom_results: list[FigureOfMeritResult], **kwargs\n    ) -&gt; ExperimentResult:\n        return backend_adapter.run(self.circuit, **kwargs)\n</code></pre>"},{"location":"reference/#qonscious.actions.qonscious_callable.QonsciousCallable","title":"<code>QonsciousCallable</code>","text":"<p>               Bases: <code>QonsciousAction</code></p> <p>A callable wraped as QonsciousAction</p> <p>Attributes:</p> Name Type Description <code>callable</code> <code> Callable[[BackendAdapter, list[FigureOfMeritResult]], ExperimentResult | None]</code> <p>the callable to execute</p> Source code in <code>src/qonscious/actions/qonscious_callable.py</code> <pre><code>class QonsciousCallable(QonsciousAction):\n    \"\"\"\n    A callable wraped as QonsciousAction\n\n    Attributes:\n        callable ( Callable[[BackendAdapter, list[FigureOfMeritResult]], ExperimentResult | None]):\n            the callable to execute\n    \"\"\"\n\n    def __init__(\n        self,\n        callable: Callable[[BackendAdapter, list[FigureOfMeritResult]], ExperimentResult | None],\n    ):\n        self.callable = callable\n\n    def run(\n        self, backend_adapter: BackendAdapter, fom_results: list[FigureOfMeritResult], **kwargs\n    ) -&gt; ExperimentResult | None:\n        return self.callable(backend_adapter, fom_results, **kwargs)\n</code></pre>"},{"location":"reference/#qonscious.run_conditionally.run_conditionally","title":"<code>run_conditionally(backend_adapter, checks, on_pass, on_fail, **kwargs)</code>","text":"<p>Main entry point of the Qonscious framework.</p> <p>Evaluates a set of merit compliance checks on the given backend and executes the appropriate action depending on whether all checks pass or any check fails.</p> <p>Parameters:</p> Name Type Description Default <code>backend_adapter</code> <code>BackendAdapter</code> <p>Adapter to the quantum backend on which figures of merit are evaluated and circuits may be executed.</p> required <code>checks</code> <code>list[MeritComplianceCheck]</code> <p>The merit compliance checks to perform on the backend.</p> required <code>on_pass</code> <code>QonsciousAction</code> <p>Action to execute if all checks succeed. Must implement <code>run(backend_adapter, fom_results, **kwargs)</code> and return an <code>ExperimentResult</code> or <code>None</code>.</p> required <code>on_fail</code> <code>QonsciousAction</code> <p>Action to execute if any check fails. Same contract as <code>on_pass</code>.</p> required <code>**kwargs</code> <p>Additional keyword arguments forwarded to the checks and actions.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>QonsciousResult</code> <code>QonsciousResult</code> <p>A result object containing the list of figure-of-merit results and, if applicable, the experiment result produced by the action.</p> Source code in <code>src/qonscious/run_conditionally.py</code> <pre><code>def run_conditionally(\n    backend_adapter: BackendAdapter,\n    checks: list[MeritComplianceCheck],\n    on_pass: QonsciousAction,\n    on_fail: QonsciousAction,\n    **kwargs,\n) -&gt; QonsciousResult:\n    \"\"\"\n    Main entry point of the Qonscious framework.\n\n    Evaluates a set of merit compliance checks on the given backend\n    and executes the appropriate action depending on whether all\n    checks pass or any check fails.\n\n    Args:\n        backend_adapter BackendAdapter : Adapter to the quantum backend on which figures of merit\n            are evaluated and circuits may be executed.\n        checks list[MeritComplianceCheck] : The merit compliance checks to perform on the backend.\n        on_pass QonsciousAction :  Action to execute if all checks succeed. Must implement\n            `run(backend_adapter, fom_results, **kwargs)` and return an `ExperimentResult` or `None`.\n        on_fail QonsciousAction : Action to execute if any check fails. Same contract as `on_pass`.\n        **kwargs : Additional keyword arguments forwarded to the checks and actions.\n\n    Returns:\n        QonsciousResult : A result object containing the list of figure-of-merit results\n            and, if applicable, the experiment result produced by the action.\n    \"\"\"\n\n    fom_results: list[FigureOfMeritResult] = []\n    passed = True\n\n    for check in checks:\n        result = check.check(backend_adapter, **kwargs)\n        fom_results.append(result[\"fom_result\"])\n        if not result[\"passed\"]:\n            passed = False\n\n    if passed:\n        run_result = on_pass.run(backend_adapter, fom_results, **kwargs)\n    else:\n        run_result = on_fail.run(backend_adapter, fom_results, **kwargs)\n\n    return {\n        \"condition\": \"pass\" if passed else \"fail\",\n        \"figures_of_merit_results\": fom_results,\n        \"experiment_result\": run_result,\n    }\n</code></pre>"}]}