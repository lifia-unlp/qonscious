{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Project overview","text":"<ul> <li>Tutorials: <ul> <li>Undertanding run_conditionally</li> <li>Qonscious notebooks </li> </ul> </li> <li>How-to guides: <ul> <li>Contribute to this project</li> <li>Create a new Backend Adapter (coming soon)</li> <li>Create a new Figure of Merit (coming son)</li> </ul> </li> <li>Reference (API): see API Reference</li> <li>Explanations/Design: (coming soon)</li> </ul>"},{"location":"#qonscious","title":"Qonscious","text":"<p>Qonscious is a runtime framework designed to support conditional execution of quantum circuits based on resource introspection. It helps you build quantum applications that are aware of backend conditions \u2014 such as entanglement, coherence, or fidelity \u2014 before execution.</p>"},{"location":"#why-qonscious","title":"Why Qonscious?","text":"<p>In the NISQ era, quantum hardware is noisy, resource-limited, and variable over time. Static resource assumptions lead to unreliable results. Qonscious makes quantum programs introspective and adaptive.</p> <p>For a deeper discusion on the motivation behind Qonscious, read our article</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Figures of Merit evaluation (e.g., get CHSH score)</li> <li>Conditional execution on compliance with figures of merit checks</li> <li>Inversion of control: pass a callback, not a circuit</li> <li>Built-in logging, extensibility, and fallback logic</li> </ul>"},{"location":"#use-cases","title":"Use cases","text":"<p>These are some scenarios where you may use Qonscious:</p> <ul> <li>Run a circuit conditional on your target computer (or simulator) checking some figures of merit (e.g., number of qubits, CHSH score, etc.)</li> <li>Benchmark a computer (or simulator) in terms of a collection of figures of merit.</li> <li>Explore correlations between experiment results and figures of merit of a gicen computer (or simulator)</li> <li>...</li> </ul>"},{"location":"#setting-up-dependencies","title":"Setting up dependencies","text":"<p>This project is organized with a pyproject.toml file, so there is no longer a need for a requirements.txt file.</p> <p>Python version is set in .python-version</p> <p>We recommend working in a Python virtual environment. The following snippet of code provides examples of most of the tasks you'll need to complete. </p> <pre><code>python -m venv .venv \nsource .venv/bin/activate\npip install -U pip wheel\npip install -e \".[dev,notebooks,viz,docs]\" # you can leave notebooks and viz out of you are only working on the framework.\n</code></pre> <p>The -e flag in pip install tells pip to install Qonscious as a dependency so you can import from any Jupyter notebook working on the same venv while lettig you edit the framework.</p>"},{"location":"#documentation","title":"Documentation","text":"<p>Up to date documentation is available on github pages</p>"},{"location":"#examples","title":"Examples","text":"<p>The notebooks folder contains several examples of using Qonscious in different use cases. </p> <p>We suggest you start with chsh_test_demo.ipynb</p>"},{"location":"#development-notes","title":"Development notes","text":""},{"location":"#visualstudio-code","title":"VisualStudio Code","text":"<p>There is a _vscode_example_settings.json file that you can rename to .vscode/settings.json . It provides most default settings that help VSC find tests, work with notebooks, etc. </p>"},{"location":"#ruff","title":"ruff","text":"<p>pyproject.toml includes default configurations for ruff (linting, etc.). Ruff is part of the [dev] dependencies.</p> <p>To use ruff from the command line (and let ruff format, and tidy up code),  do as follows:</p> <pre><code>ruff check . --fix\nruff format .\n</code></pre>"},{"location":"#pyright","title":"pyright","text":"<p>This project uses pyright as a typechecker (In VSCode it will work via PyLance).</p> <p>Settings are defined in pyrightconfig.json</p>"},{"location":"changelog/","title":"Changelog","text":"<p>Example content to imitate</p>"},{"location":"changelog/#changelog","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file. The format is based on Keep a Changelog and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#unreleased","title":"[Unreleased]","text":""},{"location":"changelog/#140-2025-08-31","title":"[1.4.0] - 2025-08-31","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>New CHSH scoring policy interface (#412).</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li><code>SamplerAdapter</code> now accepts an instantiated backend instead of a name (#405).</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Avoid crash when <code>backend.properties()</code> is unavailable (#418).</li> </ul>"},{"location":"changelog/#132-2025-07-12","title":"[1.3.2] - 2025-07-12","text":""},{"location":"changelog/#fixed_1","title":"Fixed","text":"<ul> <li>Correct T1 dictionary generation for Aer simulator (#399).</li> </ul>"},{"location":"changelog/#130-2025-06-01","title":"[1.3.0] - 2025-06-01","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li><code>MinimumAcceptableValue</code> threshold policy (#372).</li> </ul>"},{"location":"how-to/contributing/","title":"1. Introduction / Welcome","text":"<p>Thanks for your interest in Qonscious. You are welcomed to contribute with improvements, fixes, and extensions. Just keep in mind that Qonscious is in active development and it is part of a research project. In that context, we may not be able (or willing to) integrate all proposals. However, you can work on you own version of Qonsiocus is you cite this work.  </p>"},{"location":"how-to/contributing/#2-code-of-conduct-link-or-summary","title":"2.    Code of Conduct (link or summary)","text":"<ul> <li>Be nice.</li> <li>Be prepare for APIs to change. </li> <li>If you use Qonscious (or find it interesting), reference it.</li> <li>If you write an article talking about or using Qonscious, cite one of the articles listed in the project's home page. </li> </ul>"},{"location":"how-to/contributing/#3-how-to-contribute","title":"3.    How to Contribute","text":"<ul> <li>Report bugs and suggest features as Github issues.</li> <li>Asking questions by email to any of the maintainers.</li> <li>Use (piecemeal) pull request to propose changes.</li> <li>Document your code as described below.</li> </ul>"},{"location":"how-to/contributing/#4-what-to-contribute","title":"4.    What to contribute","text":"<p>Qonscious is an experimentation platform. As such, it already foresees a few extension points (where you can hang your contributions). Each of these extension point is present in the design as an abstract class, dictype or protocol that you can extend. </p> <ul> <li> <p>Adapters: Adapters (backend adapters) give Qonscious users independence from specific vendor APIs. Using adapters makes a tradeoff between abstraction (polimorphic APIs) and control (using QPU specific features). </p> </li> <li> <p>Functions of merit: Functions of Merit (FoM's) capture the charateristics of a quantum computing platform (QPU or Simulator) that are relevant for computing. Creating and using FoM's is Qonscious way on reflecting and learning about quantum computation resources in the NISQ era.</p> </li> </ul> <p>Notebooks: You can also contribute with usage examples in the form of Jupyter notebooks that use Qonscious. </p> <p>Merit compliance checks You often use FoM's to check if a given backend (i.e., adapted backend) offers the resources your use case needs. Checks (implementes as instances of the MeritComplianceCheck class) combine a FoM with a callback function that takes the result of checking that FoM on the backend and resutls true of false. Writing these checks is a bit convoluted so having many examples is useful.</p>"},{"location":"how-to/contributing/#5-versioning-and-releasing","title":"5.    Versioning and releasing","text":"<p>In the current phase of development, the design of Qonscious will change often. As we create new FoMs, provide new backend adapters, and explore usage scenarios, the API will change. There will be no PyPI version you can install with pip. For the time being, you install with <code>pip install -e</code></p>"},{"location":"how-to/contributing/#6-development-notes","title":"6.    Development notes","text":""},{"location":"how-to/contributing/#typing","title":"Typing","text":"<p>This project uses pyright as a typechecker (In VSCode it will work via PyLance). Settings are defined in pyrightconfig.json</p>"},{"location":"how-to/contributing/#formating-and-linting","title":"Formating and linting","text":"<p>This project uses ruff for formating, linting, etc.</p> <p>pyproject.toml includes default configurations for ruff</p> <p>Ruff is part of the [dev] dependencies.</p> <p>To use ruff from the command line (and let ruff format, and tidy up code),  do as follows:</p> <pre><code>ruff check . --fix\nruff format .\n</code></pre>"},{"location":"how-to/contributing/#testing","title":"Testing","text":"<p>Make sure that any extensions/improvement/changes you contribute are covered by unit tests.</p> <p>Mark test methods that interact with IBM's backend (thus requiring a token) with the annotation <code>@pytest.mark.ibm_token_required</code></p> <p>Use: * <code>pytest</code> : to run all tests * <code>pytest -m \"not ibm_token_required\"</code> : to only run tests that to not interact with IBM's backend * <code>pytest -m \"ibm_token_required\"</code> : to only run tests that that do interact with IBM's backend</p>"},{"location":"how-to/contributing/#visualstudio-code","title":"VisualStudio Code","text":"<p>There is a _vscode_example_settings.json file that you can rename to .vscode/settings.json . It provides most default settings that help VSC find tests, work with notebooks, etc. </p>"},{"location":"how-to/contributing/#keep-documentation-up-to-date","title":"Keep documentation up to date","text":"<p>We use mkdocs + mkdocstrings to generate documentation.</p>"},{"location":"how-to/contributing/#one-time-setup","title":"One-time setup","text":"<ul> <li>Install deps: <code>pip install -e \".[docs]\"</code> (or <code>pip install mkdocs mkdocs-material mkdocstrings[python]</code>)</li> <li>Ensure you have:</li> <li><code>mkdocs.yml</code> at repo root</li> <li><code>docs/index.md</code>, <code>docs/reference/index.md</code> (with <code>::: qonscious</code>)</li> </ul>"},{"location":"how-to/contributing/#write-good-docstrings-type-hints","title":"Write good docstrings + type hints","text":"<ul> <li>Use Google or NumPy style consistently.</li> <li>Public APIs should document: summary, Args, Returns, Raises, Examples.</li> </ul>"},{"location":"how-to/contributing/#preview-locally-while-writing","title":"Preview locally while writing","text":"<pre><code>mkdocs serve\n</code></pre>"},{"location":"reference/","title":"API Reference","text":""},{"location":"reference/#core","title":"Core","text":""},{"location":"reference/#qonscious.core.ExperimentResult","title":"<code>ExperimentResult</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Unified structure returned by any BackendAdapter.run() call.</p> <p>Attributes:</p> Name Type Description <code>counts</code> <code>dict[str, int]</code> <p>Dictionary mapping bitstring keys to integer counts.</p> <code>shots</code> <code>int</code> <p>The number of shots in the job that generated this result</p> <code>backend_properties</code> <code>dict[str, str]</code> <p>dictionary with various properties describing the backend                 used to run the circuit.</p> <code>timestamps</code> <code>dict[str, str]</code> <p>Optional dictionary with ISO timestamps for         'created', 'running', 'finished'.</p> <code>raw_results</code> <code>Any | None</code> <p>Backend-specific result object (e.g., SamplerResult or JobResult).</p> Source code in <code>src/qonscious/core/types.py</code> <pre><code>class ExperimentResult(TypedDict):\n    \"\"\"\n    Unified structure returned by any BackendAdapter.run() call.\n\n    Attributes:\n        counts: Dictionary mapping bitstring keys to integer counts.\n        shots: The number of shots in the job that generated this result\n        backend_properties: dictionary with various properties describing the backend\n                            used to run the circuit.\n        timestamps: Optional dictionary with ISO timestamps for\n                    'created', 'running', 'finished'.\n        raw_results: Backend-specific result object (e.g., SamplerResult or JobResult).\n    \"\"\"\n\n    counts: dict[str, int]\n    shots: int\n    backend_properties: dict[str, str]\n    timestamps: dict[str, str]\n    raw_results: Any | None\n</code></pre>"},{"location":"reference/#qonscious.core.FigureOfMeritResult","title":"<code>FigureOfMeritResult</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Unified structure returned by any FigureOfMerit evaluation. For now, speficis types of figures of merit will store their results in the properties dictionary. Refer to the documentation of each figure of merit for details. They can eventually subclass this class to better support type-checking and documentation.</p> <p>Attributes:</p> Name Type Description <code>figure_of_merit</code> <code>str</code> <p>a string identifiying the FOM this results relates to             (could be the FoM class name)</p> <code>properties</code> <code>dict[str, Any]</code> <p>dictionary with various properties describing the result.</p> <code>experiment_result</code> <code>ExperimentResult | None</code> <p>The ExperimentResult used to compute the figure of merit (if any).</p> Source code in <code>src/qonscious/core/types.py</code> <pre><code>class FigureOfMeritResult(TypedDict):\n    \"\"\"\n    Unified structure returned by any FigureOfMerit evaluation.\n    For now, speficis types of figures of merit will store their results in the properties dictionary.\n    Refer to the documentation of each figure of merit for details.\n    They can eventually subclass this class to better support type-checking and documentation.\n\n    Attributes:\n        figure_of_merit: a string identifiying the FOM this results relates to\n                        (could be the FoM class name)\n        properties: dictionary with various properties describing the result.\n        experiment_result: The ExperimentResult used to compute the figure of merit (if any).\n    \"\"\"\n\n    figure_of_merit: str\n    properties: dict[str, Any]\n    experiment_result: ExperimentResult | None\n</code></pre>"},{"location":"reference/#qonscious.core.MeritComplianceCheck","title":"<code>MeritComplianceCheck</code>","text":"<p>A flexible compliance check based on an optional Figure of Merit and a custom decision function that maps its result to a boolean.</p> Source code in <code>src/qonscious/core/merit_compliance_check.py</code> <pre><code>class MeritComplianceCheck:\n    \"\"\"\n    A flexible compliance check based on an optional Figure of Merit\n    and a custom decision function that maps its result to a boolean.\n    \"\"\"\n\n    def __init__(\n        self,\n        figure_of_merit: FigureOfMerit | None = None,\n        decision_function: Callable[[FigureOfMeritResult | None], bool] = lambda _: True,\n    ):\n        self.figure_of_merit = figure_of_merit\n        self.decision_function = decision_function\n\n    def check(self, backend_adapter: BackendAdapter, **kwargs) -&gt; dict:\n        \"\"\"\n        Evaluate the FOM if present, apply the decision function to its result,\n        and return a dict with the compliance outcome and the FOM result (if any).\n        \"\"\"\n        fom_result = None\n\n        if self.figure_of_merit is not None:\n            fom_result = self.figure_of_merit.evaluate(backend_adapter, **kwargs)\n\n        passed = self.decision_function(fom_result)\n\n        return {\"passed\": passed, \"fom_result\": fom_result}\n</code></pre>"},{"location":"reference/#qonscious.core.MeritComplianceCheck.check","title":"<code>check(backend_adapter, **kwargs)</code>","text":"<p>Evaluate the FOM if present, apply the decision function to its result, and return a dict with the compliance outcome and the FOM result (if any).</p> Source code in <code>src/qonscious/core/merit_compliance_check.py</code> <pre><code>def check(self, backend_adapter: BackendAdapter, **kwargs) -&gt; dict:\n    \"\"\"\n    Evaluate the FOM if present, apply the decision function to its result,\n    and return a dict with the compliance outcome and the FOM result (if any).\n    \"\"\"\n    fom_result = None\n\n    if self.figure_of_merit is not None:\n        fom_result = self.figure_of_merit.evaluate(backend_adapter, **kwargs)\n\n    passed = self.decision_function(fom_result)\n\n    return {\"passed\": passed, \"fom_result\": fom_result}\n</code></pre>"},{"location":"reference/#qonscious.core.QonsciousResult","title":"<code>QonsciousResult</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Unified structure returned by the QonsciousRunner run method.</p> <p>Attributes:</p> Name Type Description <code>contition</code> <p>String describing the condition under which the run executed (for now only fail/pass).</p> <code>experiment_result</code> <code>ExperimentResult | None</code> <p>ExperimentResult that was obtained in this run.</p> <code>figures_of_merit_results</code> <code>list[FigureOfMeritResult]</code> <p>FigureOfMeritResults that were considered in this run.</p> Source code in <code>src/qonscious/core/types.py</code> <pre><code>class QonsciousResult(TypedDict):\n    \"\"\"\n    Unified structure returned by the QonsciousRunner run method.\n\n    Attributes:\n        contition: String describing the condition under which the run executed (for now only fail/pass).\n        experiment_result: ExperimentResult that was obtained in this run.\n        figures_of_merit_results: FigureOfMeritResults that were considered in this run.\n    \"\"\"\n\n    condition: str\n    experiment_result: ExperimentResult | None\n    figures_of_merit_results: list[FigureOfMeritResult]\n</code></pre>"},{"location":"reference/#qonscious.core.run_conditionally","title":"<code>run_conditionally(backend_adapter, checks, on_pass, on_fail, **kwargs)</code>","text":"<p>Evaluate a set of merit compliance checks and run the appropriate callback. Returns a QonsciousResult with 'fom_results' and optionally 'execution'.</p> Source code in <code>src/qonscious/core/executor.py</code> <pre><code>def run_conditionally(\n    backend_adapter: BackendAdapter,\n    checks: list[MeritComplianceCheck],\n    on_pass: Callable[[BackendAdapter, list[FigureOfMeritResult]], ExperimentResult | None],\n    on_fail: Callable[[BackendAdapter, list[FigureOfMeritResult]], ExperimentResult | None],\n    **kwargs,\n) -&gt; QonsciousResult:\n    \"\"\"\n    Evaluate a set of merit compliance checks and run the appropriate callback.\n    Returns a QonsciousResult with 'fom_results' and optionally 'execution'.\n    \"\"\"\n\n    fom_results: list[FigureOfMeritResult] = []\n    passed = True\n\n    for check in checks:\n        result = check.check(backend_adapter, **kwargs)\n        fom_results.append(result[\"fom_result\"])\n        if not result[\"passed\"]:\n            passed = False\n\n    if passed:\n        run_result = on_pass(backend_adapter, fom_results)\n    else:\n        run_result = on_fail(backend_adapter, fom_results)\n\n    return {\n        \"condition\": \"pass\" if passed else \"fail\",\n        \"figures_of_merit_results\": fom_results,\n        \"experiment_result\": run_result,\n    }\n</code></pre>"},{"location":"reference/#adapters","title":"Adapters","text":""},{"location":"reference/#qonscious.adapters.AerSamplerAdapter","title":"<code>AerSamplerAdapter</code>","text":"<p>               Bases: <code>BackendAdapter</code></p> Source code in <code>src/qonscious/adapters/aer_sampler_adapter.py</code> <pre><code>class AerSamplerAdapter(BackendAdapter):\n    def __init__(self, sampler: Sampler | None = None):\n        self.sampler = sampler or Sampler()\n\n    @property\n    def n_qubits(self) -&gt; int:\n        \"Estimates the maximum number of qubits this computer can simulate\"\n        \"considering the available memory and some rules of thumb\"\n        return int(math.log2(psutil.virtual_memory().available / 16))\n\n    @property\n    def t1s(self) -&gt; dict[int, float]:\n        \"In an aer simulator, there is no limit on the t1.\"\n        \"It could be different if we include a noise model\"\n        return {qubit: float(\"inf\") for qubit in range(self.n_qubits)}\n\n    @property\n    def t2s(self) -&gt; dict[int, float]:\n        \"In an aer simulator, there is no limit on the t2.\"\n        \"It could be different if we include a noise model\"\n        return {qubit: float(\"inf\") for qubit in range(self.n_qubits)}\n\n    def run(self, circuit: QuantumCircuit, **kwargs) -&gt; ExperimentResult:\n        shots = kwargs.get(\"shots\", 1024)\n        created = datetime.now(timezone.utc).isoformat()\n        job = self.sampler.run(pubs=[circuit], shots=shots)\n        running = datetime.now(timezone.utc).isoformat()\n        result = job.result()[0]\n        finished = datetime.now(timezone.utc).isoformat()\n\n        raw = result.join_data()\n        arr = raw.astype(\"uint8\", copy=False) if not isinstance(raw, BitArray) else raw.array\n        counts = BitArray(arr, circuit.num_clbits).get_counts()\n\n        return {\n            \"counts\": counts,\n            \"shots\": shots,\n            \"backend_properties\": {\"name\": \"qiskit_aer.primitives.SamplerV2\"},\n            \"timestamps\": {\n                \"created\": created,\n                \"running\": running,\n                \"finished\": finished,\n            },\n            \"raw_results\": job.result(),\n        }\n</code></pre>"},{"location":"reference/#qonscious.adapters.AerSamplerAdapter.n_qubits","title":"<code>n_qubits</code>  <code>property</code>","text":"<p>Estimates the maximum number of qubits this computer can simulate</p>"},{"location":"reference/#qonscious.adapters.AerSamplerAdapter.t1s","title":"<code>t1s</code>  <code>property</code>","text":"<p>In an aer simulator, there is no limit on the t1.</p>"},{"location":"reference/#qonscious.adapters.AerSamplerAdapter.t2s","title":"<code>t2s</code>  <code>property</code>","text":"<p>In an aer simulator, there is no limit on the t2.</p>"},{"location":"reference/#qonscious.adapters.IBMSamplerAdapter","title":"<code>IBMSamplerAdapter</code>","text":"<p>               Bases: <code>BackendAdapter</code></p> Source code in <code>src/qonscious/adapters/ibm_sampler_adapter.py</code> <pre><code>class IBMSamplerAdapter(BackendAdapter):\n    def __init__(self, backend):\n        self.backend = backend\n\n    @classmethod\n    def least_busy_backend(cls, token) -&gt; Self:\n        \"\"\"Simply provide your IBM Quantum token to get an adaptor on the least busy backend.\"\"\"\n        service = QiskitRuntimeService(channel=\"ibm_quantum_platform\", token=token)\n        return cls(service.least_busy(operational=True, simulator=False))\n\n    @cached_property\n    def _backend_configuration(self):\n        \"QPU configuration obtained as indicated in https://quantum.cloud.ibm.com/docs/en/guides/get-qpu-information\"\n        \"Cached after first call - maybe we should not cache it\"\n        \"cache can be cleared with ```del obj._backend_configuration```\"\n        return self.backend.configuration()\n\n    @cached_property\n    def _backend_properties(self):\n        \"QPU dynamic information obtained as indicated in https://quantum.cloud.ibm.com/docs/en/guides/get-qpu-information\"\n        \"Cached after first call - maybe we should not cache it\"\n        \"cache can be cleared with ```del obj._backend_properties```\"\n        return self.backend.properties()\n\n    @property\n    def n_qubits(self) -&gt; int:\n        return self._backend_configuration.n_qubits\n\n    @property\n    def t1s(self) -&gt; dict[int, float]:\n        n_qubits = self._backend_configuration.n_qubits\n        return {i: self._backend_properties.t1(i) for i in range(n_qubits)}\n\n    @property\n    def t2s(self) -&gt; dict[int, float]:\n        n_qubits = self._backend_configuration.n_qubits\n        return {i: self._backend_properties.t2(i) for i in range(n_qubits)}\n\n    def run(self, circuit: QuantumCircuit, **kwargs) -&gt; ExperimentResult:\n        kwargs.setdefault(\"shots\", 1024)\n        sampler = Sampler(mode=self.backend)\n        transpiled_circuit = transpile(circuit, self.backend, optimization_level=3)\n        job = sampler.run([transpiled_circuit], **kwargs)\n        result = job.result()\n        timestamps = job.metrics().get(\"timestamps\", {})\n        counts = _extract_counts(result)\n        return {\n            \"counts\": counts,\n            \"shots\": kwargs[\"shots\"],\n            \"backend_properties\": {\"name\": self.backend.name},\n            \"timestamps\": timestamps,\n            \"raw_results\": result,\n        }\n</code></pre>"},{"location":"reference/#qonscious.adapters.IBMSamplerAdapter.least_busy_backend","title":"<code>least_busy_backend(token)</code>  <code>classmethod</code>","text":"<p>Simply provide your IBM Quantum token to get an adaptor on the least busy backend.</p> Source code in <code>src/qonscious/adapters/ibm_sampler_adapter.py</code> <pre><code>@classmethod\ndef least_busy_backend(cls, token) -&gt; Self:\n    \"\"\"Simply provide your IBM Quantum token to get an adaptor on the least busy backend.\"\"\"\n    service = QiskitRuntimeService(channel=\"ibm_quantum_platform\", token=token)\n    return cls(service.least_busy(operational=True, simulator=False))\n</code></pre>"},{"location":"reference/#figures-of-merit","title":"Figures of merit","text":""}]}